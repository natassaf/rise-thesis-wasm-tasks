// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[derive(Clone)]
pub struct WasmEvent {
    /// JSON string, host can encode any info (paths, inputs, etc.)
    pub event: _rt::String,
}
impl ::core::fmt::Debug for WasmEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("WasmEvent").field("event", &self.event).finish()
    }
}
#[derive(Clone)]
pub struct WasmResult {
    pub output: _rt::String,
}
impl ::core::fmt::Debug for WasmResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("WasmResult").field("output", &self.output).finish()
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_run_cabi<T: Guest>(arg0: *mut u8, arg1: usize) -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    let result1 = T::run(WasmEvent {
        event: _rt::string_lift(bytes0),
    });
    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
    let WasmResult { output: output3 } = result1;
    let vec4 = (output3.into_bytes()).into_boxed_slice();
    let ptr4 = vec4.as_ptr().cast::<u8>();
    let len4 = vec4.len();
    ::core::mem::forget(vec4);
    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
    *ptr2.add(0).cast::<*mut u8>() = ptr4.cast_mut();
    ptr2
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_run<T: Guest>(arg0: *mut u8) {
    let l0 = *arg0.add(0).cast::<*mut u8>();
    let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
    _rt::cabi_dealloc(l0, l1, 1);
}
pub trait Guest {
    fn run(event: WasmEvent) -> WasmResult;
}
#[doc(hidden)]
macro_rules! __export_world_ml_cabi {
    ($ty:ident with_types_in $($path_to_types:tt)*) => {
        const _ : () = { #[unsafe (export_name = "run")] unsafe extern "C" fn
        export_run(arg0 : * mut u8, arg1 : usize,) -> * mut u8 { unsafe {
        $($path_to_types)*:: _export_run_cabi::<$ty > (arg0, arg1) } } #[unsafe
        (export_name = "cabi_post_run")] unsafe extern "C" fn _post_return_run(arg0 : *
        mut u8,) { unsafe { $($path_to_types)*:: __post_return_run::<$ty > (arg0) } } };
    };
}
#[doc(hidden)]
pub(crate) use __export_world_ml_cabi;
#[cfg_attr(target_pointer_width = "64", repr(align(8)))]
#[cfg_attr(target_pointer_width = "32", repr(align(4)))]
struct _RetArea([::core::mem::MaybeUninit<u8>; 2 * ::core::mem::size_of::<*const u8>()]);
static mut _RET_AREA: _RetArea = _RetArea(
    [::core::mem::MaybeUninit::uninit(); 2 * ::core::mem::size_of::<*const u8>()],
);
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod wasi {
    pub mod nn {
        /// All inputs and outputs to an ML inference are represented as `tensor`s.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod tensor {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// The dimensions of a tensor.
            ///
            /// The array length matches the tensor rank and each element in the array describes the size of
            /// each dimension
            pub type TensorDimensions = _rt::Vec<u32>;
            /// The type of the elements in a tensor.
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum TensorType {
                Fp16,
                Fp32,
                Fp64,
                Bf16,
                U8,
                I32,
                I64,
            }
            impl ::core::fmt::Debug for TensorType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        TensorType::Fp16 => f.debug_tuple("TensorType::Fp16").finish(),
                        TensorType::Fp32 => f.debug_tuple("TensorType::Fp32").finish(),
                        TensorType::Fp64 => f.debug_tuple("TensorType::Fp64").finish(),
                        TensorType::Bf16 => f.debug_tuple("TensorType::Bf16").finish(),
                        TensorType::U8 => f.debug_tuple("TensorType::U8").finish(),
                        TensorType::I32 => f.debug_tuple("TensorType::I32").finish(),
                        TensorType::I64 => f.debug_tuple("TensorType::I64").finish(),
                    }
                }
            }
            impl TensorType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> TensorType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => TensorType::Fp16,
                        1 => TensorType::Fp32,
                        2 => TensorType::Fp64,
                        3 => TensorType::Bf16,
                        4 => TensorType::U8,
                        5 => TensorType::I32,
                        6 => TensorType::I64,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// The tensor data.
            ///
            /// Initially conceived as a sparse representation, each empty cell would be filled with zeros
            /// and the array length must match the product of all of the dimensions and the number of bytes
            /// in the type (e.g., a 2x2 tensor with 4-byte f32 elements would have a data array of length
            /// 16). Naturally, this representation requires some knowledge of how to lay out data in
            /// memory--e.g., using row-major ordering--and could perhaps be improved.
            pub type TensorData = _rt::Vec<u8>;
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Tensor {
                handle: _rt::Resource<Tensor>,
            }
            impl Tensor {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Tensor {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(
                            wasm_import_module = "wasi:nn/tensor@0.2.0-rc-2024-10-28"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]tensor"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            impl Tensor {
                #[allow(unused_unsafe, clippy::all)]
                pub fn new(dimensions: &[u32], ty: TensorType, data: &[u8]) -> Self {
                    unsafe {
                        let vec0 = dimensions;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();
                        let vec1 = data;
                        let ptr1 = vec1.as_ptr().cast::<u8>();
                        let len1 = vec1.len();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:nn/tensor@0.2.0-rc-2024-10-28"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[constructor]tensor"]
                            fn wit_import2(
                                _: *mut u8,
                                _: usize,
                                _: i32,
                                _: *mut u8,
                                _: usize,
                            ) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import2(
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                        ) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe {
                            wit_import2(
                                ptr0.cast_mut(),
                                len0,
                                ty.clone() as i32,
                                ptr1.cast_mut(),
                                len1,
                            )
                        };
                        unsafe { Tensor::from_handle(ret as u32) }
                    }
                }
            }
            impl Tensor {
                #[allow(unused_unsafe, clippy::all)]
                /// Describe the size of the tensor (e.g., 2x2x2x2 -> [2, 2, 2, 2]). To represent a tensor
                /// containing a single value, use `[1]` for the tensor dimensions.
                pub fn dimensions(&self) -> TensorDimensions {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:nn/tensor@0.2.0-rc-2024-10-28"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tensor.dimensions"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = *ptr0.add(0).cast::<*mut u8>();
                        let l3 = *ptr0
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let len4 = l3;
                        let result5 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                        result5
                    }
                }
            }
            impl Tensor {
                #[allow(unused_unsafe, clippy::all)]
                /// Describe the type of element in the tensor (e.g., `f32`).
                pub fn ty(&self) -> TensorType {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:nn/tensor@0.2.0-rc-2024-10-28"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tensor.ty"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        TensorType::_lift(ret as u8)
                    }
                }
            }
            impl Tensor {
                #[allow(unused_unsafe, clippy::all)]
                /// Return the tensor data.
                pub fn data(&self) -> TensorData {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:nn/tensor@0.2.0-rc-2024-10-28"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]tensor.data"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = *ptr0.add(0).cast::<*mut u8>();
                        let l3 = *ptr0
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let len4 = l3;
                        let result5 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                        result5
                    }
                }
            }
        }
        /// TODO: create function-specific errors (https://github.com/WebAssembly/wasi-nn/issues/42)
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod errors {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum ErrorCode {
                /// Caller module passed an invalid argument.
                InvalidArgument,
                /// Invalid encoding.
                InvalidEncoding,
                /// The operation timed out.
                Timeout,
                /// Runtime Error.
                RuntimeError,
                /// Unsupported operation.
                UnsupportedOperation,
                /// Graph is too large.
                TooLarge,
                /// Graph not found.
                NotFound,
                /// The operation is insecure or has insufficient privilege to be performed.
                /// e.g., cannot access a hardware feature requested
                Security,
                /// The operation failed for an unspecified reason.
                Unknown,
            }
            impl ::core::fmt::Debug for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        ErrorCode::InvalidArgument => {
                            f.debug_tuple("ErrorCode::InvalidArgument").finish()
                        }
                        ErrorCode::InvalidEncoding => {
                            f.debug_tuple("ErrorCode::InvalidEncoding").finish()
                        }
                        ErrorCode::Timeout => {
                            f.debug_tuple("ErrorCode::Timeout").finish()
                        }
                        ErrorCode::RuntimeError => {
                            f.debug_tuple("ErrorCode::RuntimeError").finish()
                        }
                        ErrorCode::UnsupportedOperation => {
                            f.debug_tuple("ErrorCode::UnsupportedOperation").finish()
                        }
                        ErrorCode::TooLarge => {
                            f.debug_tuple("ErrorCode::TooLarge").finish()
                        }
                        ErrorCode::NotFound => {
                            f.debug_tuple("ErrorCode::NotFound").finish()
                        }
                        ErrorCode::Security => {
                            f.debug_tuple("ErrorCode::Security").finish()
                        }
                        ErrorCode::Unknown => {
                            f.debug_tuple("ErrorCode::Unknown").finish()
                        }
                    }
                }
            }
            impl ErrorCode {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> ErrorCode {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => ErrorCode::InvalidArgument,
                        1 => ErrorCode::InvalidEncoding,
                        2 => ErrorCode::Timeout,
                        3 => ErrorCode::RuntimeError,
                        4 => ErrorCode::UnsupportedOperation,
                        5 => ErrorCode::TooLarge,
                        6 => ErrorCode::NotFound,
                        7 => ErrorCode::Security,
                        8 => ErrorCode::Unknown,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Error {
                handle: _rt::Resource<Error>,
            }
            impl Error {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Error {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(
                            wasm_import_module = "wasi:nn/errors@0.2.0-rc-2024-10-28"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]error"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            impl Error {
                #[allow(unused_unsafe, clippy::all)]
                /// Return the error code.
                pub fn code(&self) -> ErrorCode {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:nn/errors@0.2.0-rc-2024-10-28"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]error.code"]
                            fn wit_import0(_: i32) -> i32;
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import0(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = unsafe { wit_import0((self).handle() as i32) };
                        ErrorCode::_lift(ret as u8)
                    }
                }
            }
            impl Error {
                #[allow(unused_unsafe, clippy::all)]
                /// Errors can propagated with backend specific status through a string value.
                pub fn data(&self) -> _rt::String {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 2 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 2
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:nn/errors@0.2.0-rc-2024-10-28"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]error.data"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = *ptr0.add(0).cast::<*mut u8>();
                        let l3 = *ptr0
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let len4 = l3;
                        let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                        let result5 = _rt::string_lift(bytes4);
                        result5
                    }
                }
            }
        }
        /// An inference "session" is encapsulated by a `graph-execution-context`. This structure binds a
        /// `graph` to input tensors before `compute`-ing an inference:
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod inference {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Error = super::super::super::wasi::nn::errors::Error;
            pub type Tensor = super::super::super::wasi::nn::tensor::Tensor;
            /// Identify a tensor by name; this is necessary to associate tensors to
            /// graph inputs and outputs.
            pub type NamedTensor = (_rt::String, Tensor);
            /// Bind a `graph` to the input and output tensors for an inference.
            ///
            /// TODO: this may no longer be necessary in WIT
            /// (https://github.com/WebAssembly/wasi-nn/issues/43)
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct GraphExecutionContext {
                handle: _rt::Resource<GraphExecutionContext>,
            }
            impl GraphExecutionContext {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for GraphExecutionContext {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(
                            wasm_import_module = "wasi:nn/inference@0.2.0-rc-2024-10-28"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]graph-execution-context"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            impl GraphExecutionContext {
                #[allow(unused_unsafe, clippy::all)]
                /// Compute the inference on the given inputs.
                pub fn compute(
                    &self,
                    inputs: _rt::Vec<NamedTensor>,
                ) -> Result<_rt::Vec<NamedTensor>, Error> {
                    unsafe {
                        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                        struct RetArea(
                            [::core::mem::MaybeUninit<
                                u8,
                            >; 3 * ::core::mem::size_of::<*const u8>()],
                        );
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 3
                                * ::core::mem::size_of::<*const u8>()],
                        );
                        let vec2 = &inputs;
                        let len2 = vec2.len();
                        let layout2 = _rt::alloc::Layout::from_size_align_unchecked(
                            vec2.len() * (3 * ::core::mem::size_of::<*const u8>()),
                            ::core::mem::size_of::<*const u8>(),
                        );
                        let result2 = if layout2.size() != 0 {
                            let ptr = _rt::alloc::alloc(layout2).cast::<u8>();
                            if ptr.is_null() {
                                _rt::alloc::handle_alloc_error(layout2);
                            }
                            ptr
                        } else {
                            ::core::ptr::null_mut()
                        };
                        for (i, e) in vec2.into_iter().enumerate() {
                            let base = result2
                                .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                            {
                                let (t0_0, t0_1) = e;
                                let vec1 = t0_0;
                                let ptr1 = vec1.as_ptr().cast::<u8>();
                                let len1 = vec1.len();
                                *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>() = len1;
                                *base.add(0).cast::<*mut u8>() = ptr1.cast_mut();
                                *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i32>() = (t0_1).take_handle() as i32;
                            }
                        }
                        let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "wasi:nn/inference@0.2.0-rc-2024-10-28"
                        )]
                        unsafe extern "C" {
                            #[link_name = "[method]graph-execution-context.compute"]
                            fn wit_import4(_: i32, _: *mut u8, _: usize, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import4(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        ) {
                            unreachable!()
                        }
                        unsafe {
                            wit_import4((self).handle() as i32, result2, len2, ptr3)
                        };
                        let l5 = i32::from(*ptr3.add(0).cast::<u8>());
                        let result14 = match l5 {
                            0 => {
                                let e = {
                                    let l6 = *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l7 = *ptr3
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base12 = l6;
                                    let len12 = l7;
                                    let mut result12 = _rt::Vec::with_capacity(len12);
                                    for i in 0..len12 {
                                        let base = base12
                                            .add(i * (3 * ::core::mem::size_of::<*const u8>()));
                                        let e12 = {
                                            let l8 = *base.add(0).cast::<*mut u8>();
                                            let l9 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len10 = l9;
                                            let bytes10 = _rt::Vec::from_raw_parts(
                                                l8.cast(),
                                                len10,
                                                len10,
                                            );
                                            let l11 = *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<i32>();
                                            (
                                                _rt::string_lift(bytes10),
                                                unsafe {
                                                    super::super::super::wasi::nn::tensor::Tensor::from_handle(
                                                        l11 as u32,
                                                    )
                                                },
                                            )
                                        };
                                        result12.push(e12);
                                    }
                                    _rt::cabi_dealloc(
                                        base12,
                                        len12 * (3 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    result12
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l13 = *ptr3
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<i32>();
                                    unsafe {
                                        super::super::super::wasi::nn::errors::Error::from_handle(
                                            l13 as u32,
                                        )
                                    }
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        if layout2.size() != 0 {
                            _rt::alloc::dealloc(result2.cast(), layout2);
                        }
                        result14
                    }
                }
            }
        }
        /// A `graph` is a loaded instance of a specific ML model (e.g., MobileNet) for a specific ML
        /// framework (e.g., TensorFlow):
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod graph {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Error = super::super::super::wasi::nn::errors::Error;
            pub type GraphExecutionContext = super::super::super::wasi::nn::inference::GraphExecutionContext;
            /// An execution graph for performing inference (i.e., a model).
            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Graph {
                handle: _rt::Resource<Graph>,
            }
            impl Graph {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: unsafe { _rt::Resource::from_handle(handle) },
                    }
                }
                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }
                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }
            unsafe impl _rt::WasmResource for Graph {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();
                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:nn/graph@0.2.0-rc-2024-10-28")]
                        unsafe extern "C" {
                            #[link_name = "[resource-drop]graph"]
                            fn drop(_: u32);
                        }
                        unsafe { drop(_handle) };
                    }
                }
            }
            /// Describes the encoding of the graph. This allows the API to be implemented by various
            /// backends that encode (i.e., serialize) their graph IR with different formats.
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum GraphEncoding {
                Openvino,
                Onnx,
                Tensorflow,
                Pytorch,
                Tensorflowlite,
                Ggml,
                Autodetect,
            }
            impl ::core::fmt::Debug for GraphEncoding {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        GraphEncoding::Openvino => {
                            f.debug_tuple("GraphEncoding::Openvino").finish()
                        }
                        GraphEncoding::Onnx => {
                            f.debug_tuple("GraphEncoding::Onnx").finish()
                        }
                        GraphEncoding::Tensorflow => {
                            f.debug_tuple("GraphEncoding::Tensorflow").finish()
                        }
                        GraphEncoding::Pytorch => {
                            f.debug_tuple("GraphEncoding::Pytorch").finish()
                        }
                        GraphEncoding::Tensorflowlite => {
                            f.debug_tuple("GraphEncoding::Tensorflowlite").finish()
                        }
                        GraphEncoding::Ggml => {
                            f.debug_tuple("GraphEncoding::Ggml").finish()
                        }
                        GraphEncoding::Autodetect => {
                            f.debug_tuple("GraphEncoding::Autodetect").finish()
                        }
                    }
                }
            }
            impl GraphEncoding {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> GraphEncoding {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => GraphEncoding::Openvino,
                        1 => GraphEncoding::Onnx,
                        2 => GraphEncoding::Tensorflow,
                        3 => GraphEncoding::Pytorch,
                        4 => GraphEncoding::Tensorflowlite,
                        5 => GraphEncoding::Ggml,
                        6 => GraphEncoding::Autodetect,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// Define where the graph should be executed.
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum ExecutionTarget {
                Cpu,
                Gpu,
                Tpu,
            }
            impl ::core::fmt::Debug for ExecutionTarget {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        ExecutionTarget::Cpu => {
                            f.debug_tuple("ExecutionTarget::Cpu").finish()
                        }
                        ExecutionTarget::Gpu => {
                            f.debug_tuple("ExecutionTarget::Gpu").finish()
                        }
                        ExecutionTarget::Tpu => {
                            f.debug_tuple("ExecutionTarget::Tpu").finish()
                        }
                    }
                }
            }
            impl ExecutionTarget {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> ExecutionTarget {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => ExecutionTarget::Cpu,
                        1 => ExecutionTarget::Gpu,
                        2 => ExecutionTarget::Tpu,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// The graph initialization data.
            ///
            /// This gets bundled up into an array of buffers because implementing backends may encode their
            /// graph IR in parts (e.g., OpenVINO stores its IR and weights separately).
            pub type GraphBuilder = _rt::Vec<u8>;
            impl Graph {
                #[allow(unused_unsafe, clippy::all)]
                pub fn init_execution_context(
                    &self,
                ) -> Result<GraphExecutionContext, Error> {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                        let mut ret_area = RetArea(
                            [::core::mem::MaybeUninit::uninit(); 8],
                        );
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:nn/graph@0.2.0-rc-2024-10-28")]
                        unsafe extern "C" {
                            #[link_name = "[method]graph.init-execution-context"]
                            fn wit_import1(_: i32, _: *mut u8);
                        }
                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        unsafe { wit_import1((self).handle() as i32, ptr0) };
                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                        let result5 = match l2 {
                            0 => {
                                let e = {
                                    let l3 = *ptr0.add(4).cast::<i32>();
                                    unsafe {
                                        super::super::super::wasi::nn::inference::GraphExecutionContext::from_handle(
                                            l3 as u32,
                                        )
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = *ptr0.add(4).cast::<i32>();
                                    unsafe {
                                        super::super::super::wasi::nn::errors::Error::from_handle(
                                            l4 as u32,
                                        )
                                    }
                                };
                                Err(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        };
                        result5
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Load a `graph` from an opaque sequence of bytes to use for inference.
            pub fn load(
                builder: &[GraphBuilder],
                encoding: GraphEncoding,
                target: ExecutionTarget,
            ) -> Result<Graph, Error> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec1 = builder;
                    let len1 = vec1.len();
                    let layout1 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec1.len() * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result1 = if layout1.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout1).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout1);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec1.into_iter().enumerate() {
                        let base = result1
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let vec0 = e;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len0;
                            *base.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                        }
                    }
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:nn/graph@0.2.0-rc-2024-10-28")]
                    unsafe extern "C" {
                        #[link_name = "load"]
                        fn wit_import3(_: *mut u8, _: usize, _: i32, _: i32, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: i32,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(
                            result1,
                            len1,
                            encoding.clone() as i32,
                            target.clone() as i32,
                            ptr2,
                        )
                    };
                    let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                    let result7 = match l4 {
                        0 => {
                            let e = {
                                let l5 = *ptr2.add(4).cast::<i32>();
                                unsafe { Graph::from_handle(l5 as u32) }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l6 = *ptr2.add(4).cast::<i32>();
                                unsafe {
                                    super::super::super::wasi::nn::errors::Error::from_handle(
                                        l6 as u32,
                                    )
                                }
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    if layout1.size() != 0 {
                        _rt::alloc::dealloc(result1.cast(), layout1);
                    }
                    result7
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Load a `graph` by name.
            ///
            /// How the host expects the names to be passed and how it stores the graphs for retrieval via
            /// this function is **implementation-specific**. This allows hosts to choose name schemes that
            /// range from simple to complex (e.g., URLs?) and caching mechanisms of various kinds.
            pub fn load_by_name(name: &str) -> Result<Graph, Error> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec0 = name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:nn/graph@0.2.0-rc-2024-10-28")]
                    unsafe extern "C" {
                        #[link_name = "load-by-name"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result6 = match l3 {
                        0 => {
                            let e = {
                                let l4 = *ptr1.add(4).cast::<i32>();
                                unsafe { Graph::from_handle(l4 as u32) }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l5 = *ptr1.add(4).cast::<i32>();
                                unsafe {
                                    super::super::super::wasi::nn::errors::Error::from_handle(
                                        l5 as u32,
                                    )
                                }
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result6
                }
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::vec::Vec;
    use core::fmt;
    use core::marker;
    use core::sync::atomic::{AtomicU32, Ordering::Relaxed};
    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        handle: AtomicU32,
        _marker: marker::PhantomData<T>,
    }
    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    #[allow(clippy::missing_safety_doc)]
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: u32);
    }
    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
            debug_assert!(handle != u32::MAX);
            Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
            }
        }
        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> u32 {
            resource.handle.swap(u32::MAX, Relaxed)
        }
        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> u32 {
            resource.handle.load(Relaxed)
        }
    }
    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource").field("handle", &self.handle).finish()
        }
    }
    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    u32::MAX => {}
                    other => T::drop(other),
                }
            }
        }
    }
    pub use alloc_crate::string::String;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub use alloc_crate::alloc;
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_ml_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*:: __export_world_ml_cabi!($ty with_types_in
        $($path_to_types_root)*);
    };
}
#[doc(inline)]
pub(crate) use __export_ml_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:wasi:nn@0.2.0-rc-2024-10-28:ml:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1480] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xcf\x0a\x01A\x02\x01\
A\x11\x01r\x01\x05events\x03\0\x0awasm-event\x03\0\0\x01r\x01\x06outputs\x03\0\x0b\
wasm-result\x03\0\x02\x01B\x11\x01py\x04\0\x11tensor-dimensions\x03\0\0\x01m\x07\
\x04FP16\x04FP32\x04FP64\x04BF16\x02U8\x03I32\x03I64\x04\0\x0btensor-type\x03\0\x02\
\x01p}\x04\0\x0btensor-data\x03\0\x04\x04\0\x06tensor\x03\x01\x01i\x06\x01@\x03\x0a\
dimensions\x01\x02ty\x03\x04data\x05\0\x07\x04\0\x13[constructor]tensor\x01\x08\x01\
h\x06\x01@\x01\x04self\x09\0\x01\x04\0\x19[method]tensor.dimensions\x01\x0a\x01@\
\x01\x04self\x09\0\x03\x04\0\x11[method]tensor.ty\x01\x0b\x01@\x01\x04self\x09\0\
\x05\x04\0\x13[method]tensor.data\x01\x0c\x03\0\"wasi:nn/tensor@0.2.0-rc-2024-10\
-28\x05\x04\x01B\x08\x01m\x09\x10invalid-argument\x10invalid-encoding\x07timeout\
\x0druntime-error\x15unsupported-operation\x09too-large\x09not-found\x08security\
\x07unknown\x04\0\x0aerror-code\x03\0\0\x04\0\x05error\x03\x01\x01h\x02\x01@\x01\
\x04self\x03\0\x01\x04\0\x12[method]error.code\x01\x04\x01@\x01\x04self\x03\0s\x04\
\0\x12[method]error.data\x01\x05\x03\0\"wasi:nn/errors@0.2.0-rc-2024-10-28\x05\x05\
\x02\x03\0\x01\x05error\x02\x03\0\0\x06tensor\x01B\x0e\x02\x03\x02\x01\x06\x04\0\
\x05error\x03\0\0\x02\x03\x02\x01\x07\x04\0\x06tensor\x03\0\x02\x01i\x03\x01o\x02\
s\x04\x04\0\x0cnamed-tensor\x03\0\x05\x04\0\x17graph-execution-context\x03\x01\x01\
h\x07\x01p\x06\x01i\x01\x01j\x01\x09\x01\x0a\x01@\x02\x04self\x08\x06inputs\x09\0\
\x0b\x04\0'[method]graph-execution-context.compute\x01\x0c\x03\0%wasi:nn/inferen\
ce@0.2.0-rc-2024-10-28\x05\x08\x02\x03\0\x02\x17graph-execution-context\x01B\x1a\
\x02\x03\x02\x01\x06\x04\0\x05error\x03\0\0\x02\x03\x02\x01\x07\x04\0\x06tensor\x03\
\0\x02\x02\x03\x02\x01\x09\x04\0\x17graph-execution-context\x03\0\x04\x04\0\x05g\
raph\x03\x01\x01m\x07\x08openvino\x04onnx\x0atensorflow\x07pytorch\x0etensorflow\
lite\x04ggml\x0aautodetect\x04\0\x0egraph-encoding\x03\0\x07\x01m\x03\x03cpu\x03\
gpu\x03tpu\x04\0\x10execution-target\x03\0\x09\x01p}\x04\0\x0dgraph-builder\x03\0\
\x0b\x01h\x06\x01i\x05\x01i\x01\x01j\x01\x0e\x01\x0f\x01@\x01\x04self\x0d\0\x10\x04\
\0$[method]graph.init-execution-context\x01\x11\x01p\x0c\x01i\x06\x01j\x01\x13\x01\
\x0f\x01@\x03\x07builder\x12\x08encoding\x08\x06target\x0a\0\x14\x04\0\x04load\x01\
\x15\x01@\x01\x04names\0\x14\x04\0\x0cload-by-name\x01\x16\x03\0!wasi:nn/graph@0\
.2.0-rc-2024-10-28\x05\x0a\x01@\x01\x05event\x01\0\x03\x04\0\x03run\x01\x0b\x04\0\
\x1ewasi:nn/ml@0.2.0-rc-2024-10-28\x04\0\x0b\x08\x01\0\x02ml\x03\0\0\0G\x09produ\
cers\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x06\
0.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
